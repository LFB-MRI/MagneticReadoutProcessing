\hypertarget{introduction}{%
\chapter{Introduction}\label{introduction}}

\hypertarget{background-and-motivation}{%
\section{Background and Motivation}\label{background-and-motivation}}

\hypertarget{low-field-mri}{%
\subsection{Low-Field MRI}\label{low-field-mri}}

\hypertarget{shimming-procedure}{%
\subsection{Shimming procedure}\label{shimming-procedure}}

\hypertarget{aim-of-this-thesis}{%
\section{Aim of this Thesis}\label{aim-of-this-thesis}}

\hypertarget{structure}{%
\section{Structure}\label{structure}}

\hypertarget{state-of-the-art}{%
\chapter{State of the art}\label{state-of-the-art}}

\hypertarget{opensource-projects}{%
\section{Opensource projects}\label{opensource-projects}}

\hypertarget{conceptual-design}{%
\section{Conceptual design}\label{conceptual-design}}

\begin{itemize}
\tightlist
\item
  etnwicklung eines hardware uns software framework zur einfachen
  aquirierung von Meagnetfelddaten
\item
  analysetools und funktionen
\end{itemize}

\hypertarget{usecases}{%
\chapter{Usecases}\label{usecases}}

\hypertarget{unified-sensor}{%
\chapter{Unified Sensor}\label{unified-sensor}}

\begin{itemize}
\tightlist
\item
  ziel ist es einen low cost hallsensor-interface zu entwickeln welcher
  möglichst
\item
  universell
\item
  verschienee sensoren abbilden kann
\item
  mit verschienden magneten typen und formen nutzbar
\item
  reproduzierbar
\item
  1d, 2d, 3d
\item
  integration
\end{itemize}

\hypertarget{sensor-selection}{%
\section{Sensor selection}\label{sensor-selection}}

\begin{longtable}[]{@{}lllll@{}}
\caption{Implemented digital halleffect sensors
\label{Implemented_digital_halleffect_sensors.csv}}\tabularnewline
\toprule
& TLV493D-A1B6 & HMC5883L & MMC5603NJ & AS5510\tabularnewline
\midrule
\endfirsthead
\toprule
& TLV493D-A1B6 & HMC5883L & MMC5603NJ & AS5510\tabularnewline
\midrule
\endhead
Readout-Axis & 3D & 3D & 3D & 1D\tabularnewline
Temperature-Sensor & yes & no & yes & no\tabularnewline
Resolution {[}uT{]} & 98 & 0.2 & 0.007 & 48\tabularnewline
Range {[}mT{]} & ±130.0 & ±0.8 & ±3 & ±50\tabularnewline
Interface & \gls{i2c} & \gls{i2c} & \gls{i2c} & \gls{i2c}\tabularnewline
\bottomrule
\end{longtable}

\begin{itemize}
\tightlist
\item
  for higher ranges analog sensoren nutzen welche jedoch eine
  aufwändigere schaltung erfodern
\item
  datenblatte links ergänzen
\item
  alle i2c in der regel, welches eine einfache integration ermöglicht
\item
  eingebauter temperatursensor ermöglicht temperaturkompensation
\item
  conrad teslameter mit seperaten temperatursensor
\end{itemize}

\hypertarget{mechanical-structure}{%
\section{Mechanical Structure}\label{mechanical-structure}}

\begin{itemize}
\tightlist
\item
  3d druck toleranztest
\item
  magnet halterung mit kraftloser arretierung
\item
  motoren und andere unter umstaänden magnetische teile in der nähe des
  sensors
\item
  nylon schrauben, 3d druck, 3d gedruckte klemmverbindungen
\item
  später rausrechnen durch kalibierung
\end{itemize}

\hypertarget{electrical-interface}{%
\section{Electrical Interface}\label{electrical-interface}}

\begin{itemize}
\tightlist
\item
  usb, ethernet
\item
  pps input output
\item
  multiplexer for i2c sensors alredy implemented
\end{itemize}

\hypertarget{firmware}{%
\section{Firmware}\label{firmware}}

\begin{itemize}
\item
  automatic sensor detation ablaufdiagramm erst nach i2c geräte scannen
  dann analog versuchen
\item
  serial cli support for manual mode
\item
  sync impulse =\textgreater{} 1 mastersensor als taktqelle
\item
  interene mittelung und speichern der werte im buffer ringubber welcher
  bei jedem sync impuls neu belegt wird
\item
  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \setcounter{enumi}{1}
  \tightlist
  \item
    core übernimmt mittelung und auswetung
  \end{enumerate}
\item
  was durch den user implementiert werden muss klasse
\end{itemize}

\hypertarget{user-interface}{%
\subsection{User-Interface}\label{user-interface}}

\begin{figure}
\centering
\includegraphics{./generated_images/border_Sensors_(+cli).png}
\caption{Sensors \gls{cli} \label{Sensors_(+cli).png}}
\end{figure}

\begin{figure}
\centering
\includegraphics{./generated_images/border_Query_sensors_b_value_using_(+cli).png}
\caption{Query sensors b value using \gls{cli}
\label{Query_sensors_b_value_using_(+cli).png}}
\end{figure}

\begin{itemize}
\tightlist
\item
  einfache bedienung durch nutzer auch ohne weitere software
\item
  configuration
\item
  debugging
\end{itemize}

\hypertarget{sensor-syncronsisation}{%
\section{Sensor Syncronsisation}\label{sensor-syncronsisation}}

\hypertarget{example-sensors}{%
\section{Example Sensors}\label{example-sensors}}

\emph{anbei werden drei erschienee sensoren für unterschiedliche
anwedungfälle } tablle statisch dynamisch

\hypertarget{d-single-sensor}{%
\subsection{1D: Single Sensor}\label{d-single-sensor}}

\begin{figure}
\centering
\includegraphics{./generated_images/border_1D_sensor_contrsuction_with_universal_magnet_mount.png}
\caption{1D sensor contrsuction with universal magnet mount
\label{1D_sensor_contrsuction_with_universal_magnet_mount.png}}
\end{figure}

\begin{itemize}
\tightlist
\item
  einfachster aufbau rp pico + sensor
\end{itemize}

\hypertarget{d-dual-sensor}{%
\subsection{1D: Dual Sensor}\label{d-dual-sensor}}

\begin{itemize}
\tightlist
\item
  gleicher abstand zwei gleicher sensoren
\item
  schnelle erkennung der plarisationsebene ggf offset vom mittelpunkt
  dieser
\end{itemize}

\hypertarget{full-sphere}{%
\subsection{Full-Sphere}\label{full-sphere}}

\begin{figure}
\centering
\includegraphics{./generated_images/border_Full-Sphere_sensor_implementation_using_two_Nema17_stepper_motors_in_a_polar_coordinate_system.png}
\caption{Full-Sphere sensor implementation using two Nema17 stepper
motors in a polar coordinate system
\label{Full-Sphere_sensor_implementation_using_two_Nema17_stepper_motors_in_a_polar_coordinate_system.png}}
\end{figure}

\begin{itemize}
\tightlist
\item
  komplexester aufbau sensor + mechanik
\item
  polar mechanisches system
\item
  full sphere sensor
\end{itemize}

\hypertarget{integration-of-an-professional-teslameter}{%
\subsection{Integration of an Professional
Teslameter}\label{integration-of-an-professional-teslameter}}

\begin{itemize}
\tightlist
\item
  einfach anbindung professioneller teslameter
\item
  Voltkraft
\end{itemize}

\hypertarget{software-readout-framework}{%
\chapter{Software readout framework}\label{software-readout-framework}}

\begin{figure}
\centering
\includegraphics{./generated_images/border_MRPlib_COMPLETE_FLOW.png}
\caption{MRPlib COMPLETE FLOW \label{MRPlib_COMPLETE_FLOW.png}}
\end{figure}

\hypertarget{library-requirements}{%
\section{Library requirements}\label{library-requirements}}

\hypertarget{concepts}{%
\subsection{Concepts}\label{concepts}}

\begin{itemize}
\tightlist
\item
  beispiele für projekte welche nur einzelne schnritte implementieren
\item
  so kann man sich auf die implementierung
\end{itemize}

\hypertarget{user-interaction-points}{%
\subsection{User interaction points}\label{user-interaction-points}}

\begin{itemize}
\tightlist
\item
  grafik zeigen
\item
  einzelne module erleutern
\end{itemize}

\hypertarget{hal}{%
\subsubsection{HAL}\label{hal}}

\begin{itemize}
\tightlist
\item
  aufbau hal im grunde wird nur ein die commandos an das sensor cli
  weitergegeben
\item
  alle sensoren implementieren mehr oder weniger die gleichen befehle
\item
  hal gibt nur weiter und ist ``dumm''
\end{itemize}

\hypertarget{visualisation}{%
\subsubsection{Visualisation}\label{visualisation}}

\hypertarget{export}{%
\subsection{Export}\label{export}}

\begin{itemize}
\tightlist
\item
  format import export
\item
  matlab
\end{itemize}

\hypertarget{meta-data}{%
\subsubsection{Meta-Data}\label{meta-data}}

\hypertarget{multi-sensor-setup}{%
\subsection{Multi-Sensor setup}\label{multi-sensor-setup}}

At the current state of implementation, it is only possible to detect
and use sensors that are directly connected to the \gls{pc} with the
\gls{mrp}-library. This has the disadvantage that there must always be a
physical connection. This can make it difficult to install multiple
sensors in measurement setups where space or cable routing options are
limited. To make sensors connected to a small
\passthrough{\lstinline!remote!} \gls{pc} available on the network, the
\passthrough{\lstinline!Proxy!}\ref{MRPlib_Proxy_Module.png} module has
been developed. This can be a single board computer (e.g.~a Raspberry
Pi). The small footprint and low power consumption make it a good
choice. It can also be used in a temperature chamber. The approach of
implementing this via a \gls{rest} interface also offers the advantage
that several measurements or experiments can be recorded at the same
time with the sensors.

\begin{figure}
\centering
\includegraphics{./generated_images/border_MRPlib_Proxy_Module.png}
\caption{MRPlib Proxy Module \label{MRPlib_Proxy_Module.png}}
\end{figure}

Another application example is when sensors are physically separated or
there are long distances between them. By connecting several sensors via
the proxy module, it is possible to link several instances and all
sensors available in the network are available to the control \gls{pc}.

\begin{figure}
\centering
\includegraphics{./generated_images/border_mrp_proxy_multi.png}
\caption{mrp proxy multi \label{mrp_proxy_multi.png}}
\end{figure}

The figure \ref{mrp_proxy_multi.png} shows the modified
\passthrough{\lstinline!multi-proxy - multi-sensor!} topology. Here,
both proxy instances do not communicate directly with the control
\gls{pc}, but \passthrough{\lstinline!remote (+pc) \#2!} is connected to
\passthrough{\lstinline!remote (+pc) \#1!}. This is then visible as a
sensor opposite the Control \gls{pc}, even if there are several proxy
instances behind it.

\hypertarget{network-proxy}{%
\subsubsection{Network-Proxy}\label{network-proxy}}

The figure \ref{MRPlib_Proxy_Module.png} shows the separation of the
various \gls{hal} instances, which communicate with the physically
connected sensors on the \passthrough{\lstinline!remote!}-\gls{pc} and
the \passthrough{\lstinline!control!}-\gls{pc} side, which communicates
with the remote side via the network. For the user, nothing changes in
the procedure for setting up a measurement. The proxy application must
always be started\ref{lst:mrpcli_proxy_start} on the
\passthrough{\lstinline!remote!} \gls{pc} side.

\begin{lstlisting}[language=bash, caption={MRPproxy usage to enable local sensor usage over network}, label=lst:mrpcli_proxy_start]
# START PROXY INSTNACE WITH TWO LOCALLY CONNECTED SENSORS
$ python3 mrpproxy.py proxy launch /dev/ttySENSOR_A /dev/ttySENSOR_B # add another proxy instance http://proxyinstance_2.local for multi-sensor, multi-proxy chain
Proxy started. http://remotepc.local:5556/
PRECHECK: SENSOR_HAL: 1337 # SENSOR A FOUND
PRECHECK: SENSOR_HAL: 4242 # SENSOR B FOUND
Terminate  Proxy instance [y/N] [n]: 
\end{lstlisting}

After the proxy instance has been successfully started, it is optionally
possible to check the status via the \gls{rest}
interface:\ref{lst:mrpcli_config_rest}

\begin{lstlisting}[language=bash, caption={MRPproxy REST enpoiint query examples}, label=lst:mrpcli_config_rest]
    # GET PROXY STATUS
    $ wget http://proxyinstance.local:5556/proxy/status
    {
    "capabilities":[
      "static",
      "axis_b",
      "axis_x",
      "axis_y",
      "axis_z",
      "axis_temp",
      "axis_stimestamp"
   ],
   "commands":[
      "status",
      "initialize",
      "disconnect",
      "combinedsensorcnt",
      "sensorcnt",
      "readsensor",
      "temp"
   ]

   # RUN A SENSOR COMMAND AND GET THE TOTAL SENSOR COUNT
   $ wget http://proxyinstance.local:5556/proxy/command?cmd=combinedsensorcnt
   {
   "output":[
      "2"
   ]
}
}
\end{lstlisting}

The query result shows that the sensors are connected correctly and that
their capabilites have also been recognised correctly. To be able to
configure a measurement on the other, only the \gls{ip} address or host
name of the remote \gls{pc} is
required\ref{lst:mrpcli_config_using_rpc}.

\begin{lstlisting}[language=bash, caption={MRPcli usage example to connect with a network sensor}, label=lst:mrpcli_config_using_rpc]
# CONFIGURE MEASUREMENT JOB USING A PROXY INSTANCE
$ MRPcli config setupsensor testcfg --path http://proxyinstance.local:5556
> remote sensor connected: True using proxy connection:
> http://proxyinstance.local:5556 with 1 local sensor connected
\end{lstlisting}

\hypertarget{sensor-syncronisation}{%
\subsubsection{Sensor Syncronisation}\label{sensor-syncronisation}}

Another important aspect when using several sensors via the proxy system
is the synchronisation of the measurement intervals between the sensors.
Individual sensor setups do not require any additional synchronisation
information, as this is communicated via the \gls{usb} interface. If
several sensors are connected locally, they can be connected to each
other via their sync input using short cables. One sensor acts as the
central clock (see chapter \ref{sensor-syncronsisation}). this no longer
works for long distances and the syncronisation must be made via the
network connection.

If time-critical synchronisation is required, \gls{ptp} and \gls{pps}
output functionality can be used on many single-board computers, such as
the RaspberryPi Compute Module.

\begin{itemize}
\tightlist
\item
  was ptp, bild pps output
\item
  alle clients über ptp verbunden
\item
  dso bild von jeff gerling über rpi4 ptp
\end{itemize}

\hypertarget{command-router}{%
\subsubsection{Command-Router}\label{command-router}}

\begin{itemize}
\tightlist
\item
  nummerieierung zuerst lokale sensoren dann weitere proxy sensoren
\item
  commando templating
\end{itemize}

\hypertarget{examples}{%
\subsection{Examples}\label{examples}}

\hypertarget{usability-improvements}{%
\chapter{Usability improvements}\label{usability-improvements}}

Usability improvements in software libraries are crucial for efficient
and user-friendly development. Intuitive API documentation, clearly
structured code examples and improved error messages promote a smooth
developer experience. Standardised naming conventions and well
thought-out default values simplify the application. A \gls{gui} or
\gls{cli} application for complex libraries can make it easier to use,
especially for developers with less experience. Continuous feedback
through automated tests and comprehensive error logs enable faster bug
fixing. The integration of community feedback and regular updates
promotes the adaptability of the \gls{mrp}-library to changing needs.
Effective usability improvements help to speed up development processes
and increase the satisfaction of the developer community. In the
following, some of these have been added in and around the
\gls{mrp}-library, but they are only optional components for the
intended use.

\hypertarget{command-line-interface}{%
\section{Command Line Interface}\label{command-line-interface}}

\begin{figure}
\centering
\includegraphics{./generated_images/border_MRP_(+cli)_output_to_configure_a_new_measurement.png}
\caption{MRP \gls{cli} output to configure a new measurement
\label{MRP_(+cli)_output_to_configure_a_new_measurement.png}}
\end{figure}

In the first version of this \gls{mrp}-library, the user had to write
his own Python scripts even for short measurement and visualisation
tasks. However, this was already time-consuming for reading out a sensor
and configuring the measurement parameters and metadata and quickly
required more than 100 lines of new Python code. Although such examples
are provided in the documentation, it must be possible for programming
beginners in particular to use them. To simplify these tasks, a
\gls{cli}\ref{example_measurement_analysis_pipeline.png} was implemented
around this \gls{mrp}-library, which is then also supplied as a fixed
component. This \gls{cli} implements the following functionalities:

\begin{itemize}
\tightlist
\item
  Detection of connected sensors
\item
  Configuration of measurement series
\item
  Recording of measured values from stored measurement series
\item
  Simple commands for checking recorded measurement series and their
  data.
\end{itemize}

Thanks to this functionality of the \gls{cli}, it is now possible to
connect a sensor to the \gls{pc}, configure a measurement series with it
and run it at the end. The result is then an exported file with the
measured values. These can then be read in again with the
\gls{mrp}-library and processed further. The bash
code\ref{lst:mrpcli_config_run} shows this procedure in detail.

\begin{lstlisting}[language=bash, caption={CLI example for configuring a measurement run}, label=lst:mrpcli_config_run]
# CLI EXAMPLE FOR CONFIGURING A MEASUREMENT RUN
## CONFIGURE THE SENSOR TO USE
$ MRPcli config setupsensor testcfg
> 0 - Unified Sensor 386731533439 - /dev/cu.usbmodem3867315334391
> Please select one of the found sensors [0]:
> sensor connected: True 1243455
## CONFIGURE THE MEASUREMENT
$ MRPcli config setup testcfg
> CONFIGURE testcfg
> READING-NAME: [testreading]: testreading
> OUTPUT-FOLDER [/cli/reading]: /tmp/reading_folder_path
> NUMBER DATAPOINTS: [1]: 10
> NUMBER AVERAGE READINGS PER DATAPOINT: [1]: 100
# RUN THE CONFIGURED MEASUREMENT
$ MRPcli measure run
> STARTING MEASUREMENT RUN WITH FOLLOWING CONFIGS: ['testcfg']
> config-test: OK
> sensor-connection-test: OK
> START MEASUREMENT CYCLE
> sampling 10 datapoints with 100 average readings
> SID:0 DP:0 B:47.359mT TEMP:23.56
> ....
> dump_to_file testreading_ID:525771256544952_SID:0_MAG:N45_CUBIC_12x12x12.mag.json
\end{lstlisting}

\hypertarget{programmable-data-processing-pipeline}{%
\section{Programmable data processing
pipeline}\label{programmable-data-processing-pipeline}}

After it is very easy for users to carry out measurements using the
\gls{cli}, the next logical step is to analyse the recorded data. This
can involve one or several hundred data records. Again, the procedure
for the user is to write their own evaluation scripts using the
\gls{mrp}-library. This is particularly useful for complex analyses or
custom algorithms, but not necessarily for simple standard tasks such as
bias compensation or graphical plot outputs.

\begin{figure}
\centering
\includegraphics{./generated_images/border_example_measurement_analysis_pipeline.png}
\caption{example measurement analysis pipeline
\label{example_measurement_analysis_pipeline.png}}
\end{figure}

For this purpose, a further \gls{cli} application was created, which
enables the user to create and execute complex evaluation pipelines for
measurement data without programming. The
example\ref{example_measurement_analysis_pipeline.png} shows a typical
measurement data analysis pipeline, which consists of the following
steps:

\begin{itemize}
\tightlist
\item
  Import the measurements
\item
  Determine sensor bias value from imported measurements using a
  reference measurement
\item
  Apply linear temperature compensation
\item
  Export the modified measurements
\item
  Create a graphical plot of all measurements with standard deviation
\end{itemize}

In order to implement such a pipeline, the
\passthrough{\lstinline!yaml!} file format was chosen for the definition
of the pipeline, as this is easy to understand and can also be easily
edited with a text editor. Detailed examples can be found in the
documentation\cite{MagneticReadoutProcessingReadTheDocs}. The
pipeline definition consists of sections which execute the appropriate
Python commands in the background. The signatures in the
\passthrough{\lstinline!yaml!} file are called using
\passthrough{\lstinline!reflection!} and a real-time search of the
loaded
\passthrough{\lstinline!global() symbol table!}\cite{PythonGlobalSymbolTable}.
This system makes almost all Python functions available to the user. To
simplify use, a pre-defined list of tested \gls{mrp} library functions
for use in pipelines is listed in the
documentation\cite{MagneticReadoutProcessingReadTheDocs}. The
following pipeline definition\ref{lst:mrpuddp_example_yaml} shows the
previously defined steps\ref{example_measurement_analysis_pipeline.png}
as \passthrough{\lstinline!yaml!} syntax.

\begin{lstlisting}[caption={Example User Defined Processing Pipeline}, label=lst:mrpuddp_example_yaml]
stage import_readings:
  function: import_readings
  parameters:
    IP_input_folder: ./readings/fullsphere/
    IP_file_regex: 360_(.)*.mag.json

stage import_bias_reading:
  function: import_readings
  parameters:
    IP_input_folder: ./readings/fullsphere/
    IP_file_regex: bias_reading.mag.json

stage apply_bias_offset:
  function: apply_sensor_bias_offset
  parameters:
    bias_readings: stage import_bias_reading # USE RESULT FROM FUNCTION import_bias_reading
    readings_to_calibrate: stage import_readings

stage apply_temp_compensation:
  function: apply_temperature_compensation
  parameters:
    readings_to_calibrate: stage import_readings # USE RESULT FROM FUNCTION import_readings

stage plot_normal_bias_offset:
  function: plot_readings
  parameters:
    readings_to_plot: stage apply_temp_compensation
    IP_export_folder: ./readings/fullsphere/plots/
    IP_plot_headline_prefix:  Sample N45 12x12x12 magnets calibrated

stage export_readings:
  function: export_readings
  parameters:
    readings_to_plot: stage apply_temp_compensation
    IP_export_folder: ./readings/fullsphere/plots/
\end{lstlisting}

Each pipeline step is divided into \passthrough{\lstinline!stages!},
which contain a name, the function to be executed and its parameters.
The various steps are then linked by using the
\passthrough{\lstinline!stage <name>!} as the input parameter of the
next function to be executed (see comments in
\ref{lst:mrpuddp_example_yaml}). It is therefore also possible to use
the results of one function in several others without them directly
following each other. The disadvantages of this system are as the
following:

\begin{itemize}
\tightlist
\item
  No loops can be created
\item
  Complex determination of the execution sequence of the steps
\end{itemize}

To determine the order of the pipeline steps, the parser script created
converts them into one problem of the graph theories. Each step
represents a node in the graph and the steps referred to by the input
parameter form the edges.

After several simplification steps, determination of possible start
steps and repeated traversal, the final execution sequence can be
determined in the form of a call
tree\ref{Result_step_execution_tree_from_user_defined_processing_pipeline_example.png}.

\begin{figure}
\centering
\includegraphics{./generated_images/border_Result_step_execution_tree_from_user_defined_processing_pipeline_example.png}
\caption{Result step execution tree from user defined processing
pipeline example
\label{Result_step_execution_tree_from_user_defined_processing_pipeline_example.png}}
\end{figure}

The individual steps are then executed along the graph. The intermediate
results and the final result are saved for later use.

\begin{itemize}
\tightlist
\item
  vorteile erleutern kurz
\end{itemize}

\hypertarget{tests}{%
\section{Tests}\label{tests}}

Software tests in libraries offer numerous advantages for improving
quality and efficiency. Firstly, they enable the identification of
errors and vulnerabilities before software is published as a new
version. This significantly improves the reliability of
\gls{mrp}-library applications. Tests also ensures consistent and
reliable performance, which is particularly important when libraries are
used by different users and for different usecases.

\begin{figure}
\centering
\includegraphics{./generated_images/border_MRP_library_test_results_for_different_submodules_executed_in_PyCharm_(+ide).png}
\caption{MRP library test results for different submodules executed in
PyCharm \gls{ide}
\label{MRP_library_test_results_for_different_submodules_executed_in_PyCharm_(+ide).png}}
\end{figure}

During the development of the \gls{mrp}-library, test cases were also
created for all important functionalities and use cases. The test
framework \passthrough{\lstinline!PyTest!}\cite{PyTest} was used for
this purpose, as it offers direct integration in most \gls{ide}s (see
\ref{MRP_library_test_results_for_different_submodules_executed_in_PyCharm_(+ide).png})
and also because it provides detailed and easy-to-understand test
reports as output in order to quickly identify and correct errors. It
also allows to tag tests, which is useful for grouping tests or
excluding certain tests in certain build environment scenarios. Since
all intended use cases were mapped using the test cases created, the
code of the test cases could later be used in slightly simplified
variants\ref{lst:pytest_example_code} as examples for the documentation.

\begin{lstlisting}[language=Python, caption={Example pytest class for testing MRPReading module functions}, label=lst:pytest_example_code]
# $ cat test_mrpreading.py
class TestMPRReading(unittest.TestCase):
  # PREPARE A INITIAL CONFIGURATION FILE FOR ALL FOLLOWING TEST CASES IN THIS FILE
  def setUp(self) -> None:
      self.test_folder: str = os.path.join(os.path.dirname(os.path.abspath(__file__)), "tmp")
      self.test_file:str = os.path.join(self.import_export_test_folderpath, "tmp")

  def test_matrix(self):
      reading: MRPReading = MRPSimulation.generate_reading()
      matrix: np.ndarray = reading.to_numpy_matrix()
      n_phi: float = reading.measurement_config.n_phi
      n_theta: float = reading.measurement_config.n_theta
      # CHECK MATRIX SHAPE
      self.assertTrue(matrix.shape != (n_theta,))
      self.assertTrue(len(matrix.shape) <= n_phi))

  def test_export_reading(self) -> None:
      reading: MRPReading = self.test_reading_init()
      self.assertIsNotNone(reading)
      # EXPORT READING TO A FILE
      reading.dump_to_file(self.test_file)

  def test_import_reading(self):
      # CREATE EMPTY READING
      reading_imported:MRPReading = MRPReading.MRPReading(None)
      # LOAD READING FROM FILE
      reading_imported.load_from_file(self.test_file)
      # CHECK IF ENTRIES ARE POPULATED
      self.assertIsNotNone(reading_imported.additional_data)
      self.assertIsNotNone(reading_imported.data)
\end{lstlisting}

One problem, however, is the parts of the \gls{mrp}-library that require
direct access to external hardware. These are, for example, the
\passthrough{\lstinline!MRPHal!} and
\passthrough{\lstinline!MRPHalRest!} modules, which are required to read
out sensors connected via the network. Two different approaches were
used here. In the case of local development, the test runs were carried
out on a \gls{pc} that can reach the network hardware and thus the test
run could be carried out with real data.

In the other scenario, the tests are to be carried out before a new
release in the repository on the basis of
\passthrough{\lstinline!Github Actions!}\cite{GithubActions}. Here
there is the possibility to host local runner software, which then has
access to the hardware, but then a \gls{pc} must be permanently
available for this task. Instead, the hardware sensors were simulated by
software and executed via virtualisation on the systems provided by
\passthrough{\lstinline!Github Actions!}\cite{GithubActions}.

\hypertarget{package-distribution}{%
\section{Package distribution}\label{package-distribution}}

One important point that improves usability for users is the simple
installation of the \gls{mrp}-library. As it was created in the Python
programming language, there are several public package directories where
users can provide their software modules. Here,
\passthrough{\lstinline!PyPi!}\cite{PyPI}\ref{MagneticReadoutProcessing_library_hosted_on_PyPi.png}\cite{MagneticReadoutProcessingPyPI}
is the most commonly used package directory and offers direct support
for the package installation programm
\gls{pip}\ref{lst:setup_lib_with_pip}.

\begin{figure}
\centering
\includegraphics{./generated_images/border_MagneticReadoutProcessing_library_hosted_on_PyPi.png}
\caption{MagneticReadoutProcessing library hosted on PyPi
\label{MagneticReadoutProcessing_library_hosted_on_PyPi.png}}
\end{figure}

In doing so, \gls{pip} not only manages possible package dependencies,
but also manages the installation of different versions of a package. In
addition, the version compatibility is also checked during the
installation of a new package, which can be resolved manually by the
user in the event of conflicts.

\begin{lstlisting}[language=bash, caption={Bash commands to install the MagneticReadoutProcessing (+mrp)-library using pip}, label=lst:setup_lib_with_pip]
# https://pypi.org/project/MagneticReadoutProcessing/
# install the latest version
$ pip3 install MagneticReadoutProcessing
# install the specific version 1.4.0
$ pip3 install MagneticReadoutProcessing==1.4.0
\end{lstlisting}

To make the \gls{mrp}-library compatible with the package directory,
Python provides separate installation routines that build a package in
an isolated environment and then provide an installation
\passthrough{\lstinline!wheel!} archive. This can then be uploaded to
the package directory.

Since the \gls{mrp}-library requires additional dependencies
(e.g.~\passthrough{\lstinline!numpy!},
\passthrough{\lstinline!matplotlib!}), which cannot be assumed to be
already installed on the target system, these must be installed prior to
the actual installation. These can be specified in the \gls{mrp}-library
installation configuration
\passthrough{\lstinline!setup.py!}\ref{lst:setup_py_req} for this
purpose.

\begin{lstlisting}[language=Python, caption={setup.py with dynamic requirement parsing used given requirements.txt}, label=lst:setup_py_req]
# dynamic requirement loading using 'requirements.txt'
req_path = './requirements.txt'
with pathlib.Path(req_path).open() as requirements_txt:
    install_requires = [str(requirement) for requirement in pkg_resources.parse_requirements(requirements_txt)]

setup(name='MagneticReadoutProcessing',
      version='1.4.3',
      url='https://github.com/LFB-MRI/MagnetCharacterization/',
      packages= ['MRP', 'MRPcli', 'MRPudpp', 'MRPproxy'],
      install_requires=install_requires,
      entry_points={
          'console_scripts': [
            'MRPCli = MRPcli.cli:run',
            'MRPUdpp = MRPudpp.uddp:run',
            'MRPproxy = MRPproxy.mrpproxy:run'
          ]
      }
    )
\end{lstlisting}

To make the \gls{cli} scripts written in Python easier for the user to
execute without having to use the \passthrough{\lstinline!python3!}
prefix. This has been configured in the installation configuration using
the \passthrough{\lstinline!entry\_points!} option, and the following
commands are available to the user:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!MRPcli --help!} instead of
  \passthrough{\lstinline!python3 cli.py --help!}
\item
  \passthrough{\lstinline!MRPudpp --help!} instead of
  \passthrough{\lstinline!python3 udpp.py --help!}
\item
  \passthrough{\lstinline!MRPproxy --help!} instead of
  \passthrough{\lstinline!python3 proxy.py --help!}
\end{itemize}

In addition, these commands are available globally in the system without
the terminal shell being located in the \gls{mrp}-library folder.

\hypertarget{documentation}{%
\subsection{Documentation}\label{documentation}}

In order to provide comprehensive documentation for the enduser, the
source code was documented using
Python-\passthrough{\lstinline!docstrings!}\cite{PythonDocstringReference}
and the Python3.5 type annotations:

\begin{itemize}
\tightlist
\item
  Function description
\item
  Input parameters - using \passthrough{\lstinline!param!} and
  \passthrough{\lstinline!type!}
\item
  Return value - using \passthrough{\lstinline!returns!},
  \passthrough{\lstinline!rtype!}
\end{itemize}

The use of type annotations also simplifies further development, as
modern \gls{ide}s can more reliably display possible methods to the user
as an assistance.\ref{pydocstring}

\begin{lstlisting}[language=Python, caption={Python docstring example}, label=lst:pydocstring]
    # MRPDataVisualisation.py - example docstring
    def plot_temperature(_readings: [MRPReading.MRPReading], _title: str = '', _filename: str = None, _unit: str = "degree C") -> str:
        """
        Plots a temperature plot of the reading data as figure
        :param _readings: readings to plot
        :type _readings: list(MRPReading.MRPReading)
        :param _title: Title text of the figure, embedded into the head
        :type _title: str
        :param _filename: export graphic to an given absolute filepath with .png
        :type _filename: str
        :returns: returns the abs filepath of the generated file
        :rtype: str
        """
        if _readings is None or len(_readings) <= 0:
            raise MRPDataVisualizationException("no readings in _reading given")
        num_readings = len(_readings)
        # ...
\end{lstlisting}

Since `docstrings' only document the source code, but do not provide
simple how-to-use instructions, the documentation framework
\passthrough{\lstinline!Sphinx!}\cite{SphinxDocumentation} was used
for this purpose. This framework makes it possible to generate
\gls{html} or \gls{pdf} documentation from various source code
documentation formats, such as the used
\passthrough{\lstinline!docstrings!}. These are converted into a
Markdown format in an intermediate step and this also allows to add
further user documentation such as examples or installation
instructions.

In order to make the documentation created by
\passthrough{\lstinline!Sphinx!} accessible to the user, there are, as
with the package management by \passthrough{\lstinline!PyPi!} services,
which provide Python \gls{mrp}-library documentation online.

\begin{figure}
\centering
\includegraphics{./generated_images/border_MagneticReadoutProcessing_documentation_hosted_on_ReadTheDocs.png}
\caption{MagneticReadoutProcessing documentation hosted on ReadTheDocs
\label{MagneticReadoutProcessing_documentation_hosted_on_ReadTheDocs.png}}
\end{figure}

Once the finished documentation has been generated from static
\gls{html} files, it is stored in the project repository. Another
publication option is to host the documentation via online services such
as \passthrough{\lstinline!ReadTheDocs!}\cite{ReadTheDocs}, where
users can make documentation for typical software projects available to
others.

The documentation has also been uploaded for
\passthrough{\lstinline!ReadTheDocs!}\cite{MagneticReadoutProcessingReadTheDocs}
and linked in the repository and on the overview
page\ref{MagneticReadoutProcessing_documentation_hosted_on_ReadTheDocs.png}
on \passthrough{\lstinline!PyPi!}.

The process of creating and publishing the documentation has been
automated using
\passthrough{\lstinline!GitHub Actions!}\cite{GithubActions}, so
that it is always automatically kept up to date with new features.

\hypertarget{evaluation}{%
\chapter{Evaluation}\label{evaluation}}

\hypertarget{prequesites-for-evaluation}{%
\section{Prequesites for evaluation}\label{prequesites-for-evaluation}}

\begin{figure}
\centering
\includegraphics{./generated_images/border_testmagnets_in_holder.png}
\caption{testmagnets in holder \label{testmagnets_in_holder.png}}
\end{figure}

\hypertarget{evaluation-confiugration}{%
\section{Evaluation confiugration}\label{evaluation-confiugration}}

\hypertarget{sensor-readout}{%
\subsection{Sensor readout}\label{sensor-readout}}

\hypertarget{processing-pipeline}{%
\subsection{Processing pipeline}\label{processing-pipeline}}

\hypertarget{test-scenarios}{%
\section{Test scenarios}\label{test-scenarios}}

\hypertarget{results}{%
\section{Results}\label{results}}

\hypertarget{conclusion-and-dicussion}{%
\chapter{Conclusion and dicussion}\label{conclusion-and-dicussion}}

\hypertarget{conclusion}{%
\section{Conclusion}\label{conclusion}}

\hypertarget{problems}{%
\section{Problems}\label{problems}}

\hypertarget{outlook}{%
\section{Outlook}\label{outlook}}

\begin{itemize}
\tightlist
\item
  magfield camera
\end{itemize}

