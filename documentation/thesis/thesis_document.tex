\hypertarget{introduction}{%
\chapter{Introduction}\label{introduction}}

\hypertarget{background-and-motivation}{%
\section{Background and Motivation}\label{background-and-motivation}}

\hypertarget{low-field-mri}{%
\subsection{Low-Field MRI}\label{low-field-mri}}

\hypertarget{shimming-procedure}{%
\subsection{Shimming procedure}\label{shimming-procedure}}

\hypertarget{aim-of-this-thesis}{%
\section{Aim of this Thesis}\label{aim-of-this-thesis}}

\hypertarget{structure}{%
\section{Structure}\label{structure}}

\hypertarget{state-of-the-art}{%
\chapter{State of the art}\label{state-of-the-art}}

\hypertarget{opensource-projects}{%
\section{Opensource projects}\label{opensource-projects}}

\hypertarget{conceptual-design}{%
\section{Conceptual design}\label{conceptual-design}}

\begin{itemize}
\tightlist
\item
  etnwicklung eines hardware uns software framework zur einfachen
  aquirierung von Meagnetfelddaten
\item
  analysetools und funktionen
\end{itemize}

\hypertarget{unified-sensor}{%
\chapter{Unified Sensor}\label{unified-sensor}}

\begin{itemize}
\tightlist
\item
  ziel ist es einen low cost hallsensor-interface zu entwickeln welcher
  möglichst
\item
  universell
\item
  verschienee sensoren abbilden kann
\item
  mit verschienden magneten typen und formen nutzbar
\item
  reproduzierbar
\item
  1d, 2d, 3d
\item
  integration
\end{itemize}

\hypertarget{sensor-selection}{%
\section{Sensor selection}\label{sensor-selection}}

\begin{longtable}[]{@{}lllll@{}}
\caption{Implemented digital halleffect sensors
\label{Implemented_digital_halleffect_sensors.csv}}\tabularnewline
\toprule
& TLV493D-A1B6 & HMC5883L & MMC5603NJ & AS5510\tabularnewline
\midrule
\endfirsthead
\toprule
& TLV493D-A1B6 & HMC5883L & MMC5603NJ & AS5510\tabularnewline
\midrule
\endhead
Readout-Axis & 3D & 3D & 3D & 1D\tabularnewline
Temperature-Sensor & yes & no & yes & no\tabularnewline
Resolution {[}uT{]} & 98 & 0.2 & 0.007 & 48\tabularnewline
Range {[}mT{]} & ±130.0 & ±0.8 & ±3 & ±50\tabularnewline
Interface & \gls{i2c} & \gls{i2c} & \gls{i2c} & \gls{i2c}\tabularnewline
\bottomrule
\end{longtable}

\begin{itemize}
\tightlist
\item
  for higher ranges analog sensoren nutzen welche jedoch eine
  aufwändigere schaltung erfodern
\item
  datenblatte links ergänzen
\item
  alle i2c in der regel, welches eine einfache integration ermöglicht
\item
  eingebauter temperatursensor ermöglicht temperaturkompensation
\item
  conrad teslameter mit seperaten temperatursensor
\end{itemize}

\hypertarget{mechanical-structure}{%
\section{Mechanical Structure}\label{mechanical-structure}}

\begin{itemize}
\tightlist
\item
  3d druck toleranztest
\item
  magnet halterung mit kraftloser arretierung
\item
  motoren und andere unter umstaänden magnetische teile in der nähe des
  sensors
\item
  nylon schrauben, 3d druck, 3d gedruckte klemmverbindungen
\item
  später rausrechnen durch kalibierung
\end{itemize}

\hypertarget{electrical-interface}{%
\section{Electrical Interface}\label{electrical-interface}}

\begin{itemize}
\tightlist
\item
  usb, ethernet
\item
  pps input output
\item
  multiplexer for i2c sensors alredy implemented
\end{itemize}

\hypertarget{firmware}{%
\section{Firmware}\label{firmware}}

\begin{itemize}
\item
  automatic sensor detation ablaufdiagramm erst nach i2c geräte scannen
  dann analog versuchen
\item
  serial cli support for manual mode
\item
  sync impulse =\textgreater{} 1 mastersensor als taktqelle
\item
  interene mittelung und speichern der werte im buffer ringubber welcher
  bei jedem sync impuls neu belegt wird
\item
  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \setcounter{enumi}{1}
  \tightlist
  \item
    core übernimmt mittelung und auswetung
  \end{enumerate}
\item
  was durch den user implementiert werden muss klasse
\end{itemize}

\hypertarget{cli-interface}{%
\subsection{\texorpdfstring{\gls{cli})
Interface}{ Interface}}\label{cli-interface}}

\begin{figure}
\centering
\includegraphics{./generated_images/border_Sensors_CL-Interface.png}
\caption{Sensors CL-Interface \label{Sensors_CL-Interface.png}}
\end{figure}

\begin{figure}
\centering
\includegraphics{./generated_images/border_Query_sensors_b_value_using_(+cli).png}
\caption{Query sensors b value using \gls{cli}
\label{Query_sensors_b_value_using_(+cli).png}}
\end{figure}

\begin{itemize}
\tightlist
\item
  einfache bedienung durch nutzer auch ohne weitere software
\item
  configuration
\item
  debugging
\end{itemize}

\hypertarget{sensor-syncronsisation}{%
\section{Sensor Syncronsisation}\label{sensor-syncronsisation}}

\hypertarget{example-sensors}{%
\section{Example Sensors}\label{example-sensors}}

\emph{anbei werden drei erschienee sensoren für unterschiedliche
anwedungfälle } tablle statisch dynamisch

\hypertarget{d-single-sensor}{%
\subsection{1D: Single Sensor}\label{d-single-sensor}}

\begin{figure}
\centering
\includegraphics{./generated_images/border_1D_sensor_contrsuction_with_universal_magnet_mount.png}
\caption{1D sensor contrsuction with universal magnet mount
\label{1D_sensor_contrsuction_with_universal_magnet_mount.png}}
\end{figure}

\begin{itemize}
\tightlist
\item
  einfachster aufbau rp pico + sensor
\end{itemize}

\hypertarget{d-dual-sensor}{%
\subsection{1D: Dual Sensor}\label{d-dual-sensor}}

\begin{itemize}
\tightlist
\item
  gleicher abstand zwei gleicher sensoren
\item
  schnelle erkennung der plarisationsebene ggf offset vom mittelpunkt
  dieser
\end{itemize}

\hypertarget{full-sphere}{%
\subsection{Full-Sphere}\label{full-sphere}}

\begin{figure}
\centering
\includegraphics{./generated_images/border_Full-Sphere_sensor_implementation_using_two_Nema17_stepper_motors_in_a_polar_coordinate_system.png}
\caption{Full-Sphere sensor implementation using two Nema17 stepper
motors in a polar coordinate system
\label{Full-Sphere_sensor_implementation_using_two_Nema17_stepper_motors_in_a_polar_coordinate_system.png}}
\end{figure}

\begin{itemize}
\tightlist
\item
  komplexester aufbau sensor + mechanik
\item
  polar mechanisches system
\item
  full sphere sensor
\end{itemize}

\hypertarget{integration-of-an-professional-teslameter}{%
\subsection{Integration of an Professional
Teslameter}\label{integration-of-an-professional-teslameter}}

\begin{itemize}
\tightlist
\item
  einfach anbindung professioneller teslameter
\item
  Voltkraft
\end{itemize}

\hypertarget{software-readout-framework}{%
\chapter{Software readout framework}\label{software-readout-framework}}

\begin{figure}
\centering
\includegraphics{./generated_images/border_MRPlib_COMPLETE_FLOW.png}
\caption{MRPlib COMPLETE FLOW \label{MRPlib_COMPLETE_FLOW.png}}
\end{figure}

\hypertarget{library-requirements}{%
\section{Library requirements}\label{library-requirements}}

\hypertarget{concepts}{%
\subsection{Concepts}\label{concepts}}

\begin{itemize}
\tightlist
\item
  beispiele für projekte welche nur einzelne schnritte implementieren
\item
  so kann man sich auf die implementierung
\end{itemize}

\hypertarget{user-interaction-points}{%
\subsection{User interaction points}\label{user-interaction-points}}

\begin{itemize}
\tightlist
\item
  grafik zeigen
\item
  einzelne module erleutern
\end{itemize}

\hypertarget{hal}{%
\subsubsection{HAL}\label{hal}}

\begin{itemize}
\tightlist
\item
  aufbau hal im grunde wird nur ein die commandos an das sensor cli
  weitergegeben
\item
  alle sensoren implementieren mehr oder weniger die gleichen befehle
\item
  hal gibt nur weiter und ist ``dumm''
\end{itemize}

\hypertarget{visualisation}{%
\subsubsection{Visualisation}\label{visualisation}}

\hypertarget{export}{%
\subsection{Export}\label{export}}

\begin{itemize}
\tightlist
\item
  format import export
\item
  matlab
\end{itemize}

\hypertarget{meta-data}{%
\subsubsection{Meta-Data}\label{meta-data}}

\hypertarget{multi-sensor-setup}{%
\subsection{Multi-Sensor setup}\label{multi-sensor-setup}}

At the current state of implementation, it is only possible to detect
and use sensors that are directly connected to the \gls{pc} with the
library. This has the disadvantage that there must always be a physical
connection. This can make it difficult to install multiple sensors in
measurement setups where space or cable routing options are limited. To
make sensors connected to a small \passthrough{\lstinline!remote!}
\gls{pc} available on the network, the
\passthrough{\lstinline!Proxy!}\ref{MRPlib_Proxy_Module.png} module has
been developed. This can be a single board computer (e.g.~a Raspberry
Pi). The small footprint and low power consumption make it a good
choice. It can also be used in a temperature chamber. The approach of
implementing this via a \gls{rest} interface also offers the advantage
that several measurements or experiments can be recorded at the same
time with the sensors.

\begin{figure}
\centering
\includegraphics{./generated_images/border_MRPlib_Proxy_Module.png}
\caption{MRPlib Proxy Module \label{MRPlib_Proxy_Module.png}}
\end{figure}

Another application example is when sensors are physically separated or
there are long distances between them. By connecting several sensors via
the proxy module, it is possible to link several instances and all
sensors available in the network are available to the control \gls{pc}.

\begin{figure}
\centering
\includegraphics{./generated_images/border_mrp_proxy_multi.png}
\caption{mrp proxy multi \label{mrp_proxy_multi.png}}
\end{figure}

The graphic \ref{mrp_proxy_multi.png} shows the modified
\passthrough{\lstinline!multi-proxy - multi-sensor!} topology. Here,
both proxy instances do not communicate directly with the control
\gls{pc}, but \passthrough{\lstinline!remote (+pc) \#2!} is connected to
\passthrough{\lstinline!remote (+pc) \#1!}. This is then visible as a
sensor opposite the Control \gls{pc}, even if there are several proxy
instances behind it.

\hypertarget{network-proxy}{%
\subsubsection{Network-Proxy}\label{network-proxy}}

The graphic \ref{MRPlib_Proxy_Module.png} shows the separation of the
various \gls{hal} instances, which communicate with the physically
connected sensors on the \passthrough{\lstinline!remote!}-\gls{pc} and
the \passthrough{\lstinline!control!}-\gls{pc} side, which communicates
with the remote side via the network. For the user, nothing changes in
the procedure for setting up a measurement. The proxy application must
always be started on the \passthrough{\lstinline!remote!} \gls{pc} side.

\begin{lstlisting}[language=bash]
    # START PROXY INSTNACE WITH TWO LOCALLY CONNECTED SENSORS
    $ python3 mrpproxy.py proxy launch /dev/ttySENSOR_A /dev/ttySENSOR_B # add another proxy instance http://proxyinstance_2.local for multi-sensor, multi-proxy chain
    Proxy started. http://0.0.0.0:5556/
    PRECHECK: SENSOR_HAL: 1337 # SENSOR A FOUND
    PRECHECK: SENSOR_HAL: 4242 # SENSOR B FOUND
    Terminate  [Y/n] [y]: 
\end{lstlisting}

After the proxy instance has been successfully started, it is optionally
possible to check the status via the \gls{rest} interface:

\begin{lstlisting}[language=bash]
    # GET PROXY STATUS
    $ wget http://proxyinstance.local:5556/proxy/status
    {
    "capabilities":[
      "static",
      "axis_b",
      "axis_x",
      "axis_y",
      "axis_z",
      "axis_temp",
      "axis_stimestamp"
   ],
   "commands":[
      "status",
      "initialize",
      "disconnect",
      "combinedsensorcnt",
      "sensorcnt",
      "readsensor",
      "temp"
   ]

   # RUN A SENSOR COMMAND AND GET THE TOTAL SENSOR COUNT
   $ wget http://proxyinstance.local:5556/proxy/command?cmd=combinedsensorcnt
   {
   "output":[
      "2"
   ]
}
}
\end{lstlisting}

The query result shows that the sensors are connected correctly and that
their capabilites have also been recognised correctly. To be able to
configure a measurement on the other, only the \gls{ip} address or host
name of the remote \gls{pc} is required:

\begin{lstlisting}[language=bash]
  # CONFIGURE MEASUREMENT JOB USING A PROXY INSTANCE
  $ python3 mrpproxy.py proxy launch /dev/ttySENSOR_A /dev/ttySENSOR_B
\end{lstlisting}

\hypertarget{sensor-syncronisation}{%
\subsubsection{Sensor Syncronisation}\label{sensor-syncronisation}}

Another important aspect when using several sensors via the proxy system
is the synchronisation of the measurement intervals between the sensors.
Individual sensor setups do not require any additional synchronisation
information, as this is communicated via the \gls{usb} interface. If
several sensors are connected locally, they can be connected to each
other via their sync input using short cables. One sensor acts as the
central clock (see chapter \ref{sensor-syncronsisation}). However, this
no longer works for long distances and the syncronisation must be made
via the network connection.

If time-critical synchronisation is required, \gls{ptp} and \gls{pps}
output functionality can be used on many single-board computers, such as
the RaspberryPi Compute Module.

\begin{itemize}
\tightlist
\item
  was ptp, bild pps output
\item
  alle clients über ptp verbunden
\item
  dso bild von jeff gerling über rpi4 ptp
\end{itemize}

\hypertarget{command-router}{%
\subsubsection{Command-Router}\label{command-router}}

\begin{itemize}
\tightlist
\item
  nummerieierung zuerst lokale sensoren dann weitere proxy sensoren
\item
  commando templating
\end{itemize}

\hypertarget{examples}{%
\subsection{Examples}\label{examples}}

\hypertarget{usability-improvements}{%
\chapter{Usability improvements}\label{usability-improvements}}

\hypertarget{commandline-interface}{%
\section{Commandline interface}\label{commandline-interface}}

\begin{itemize}
\tightlist
\item
  automatische sensor dedettion
\item
  planung verschiedener messungen mit untersch. hardware
\item
  zentrale abarbeitung
\end{itemize}

\hypertarget{programmable-data-processing-pipeline}{%
\section{Programmable data processing
pipeline}\label{programmable-data-processing-pipeline}}

\begin{figure}
\centering
\includegraphics{./generated_images/border_example_measurement_analysis_pipeline.png}
\caption{example measurement analysis pipeline
\label{example_measurement_analysis_pipeline.png}}
\end{figure}

\begin{itemize}
\tightlist
\item
  datenanalyse für nicht programmieruer
\item
  automatisierter aufbau der call-tree
\item
  mit typcheck
\item
  alle funktionen mit bestimmer signtur werden automatisch aus globals
  geladen und stehen nutzer zur verfühung
\end{itemize}

\begin{lstlisting}
# pipeline_example_measurement_processing.yaml
settings:
 enabled: true
 export_intermediate_results: false
 name: pipeline_example_measurement_processing

stage import_readings:
 function: import_readings
 parameters:
   IP_input_folder: ./readings/fullsphere/
   IP_file_regex: 360_(.)*.mag.json

stage import_bias_reading:
 function: import_readings
 parameters:
   IP_input_folder: ./readings/fullsphere/
   IP_file_regex: bias_reading.mag.json

stage apply_bias_offset:
 function: apply_sensor_bias_offset
 parameters:
   bias_readings: stage import_bias_reading
   readings_to_calibrate: stage import_readings

stage apply_temp_compensation:
 function: apply_temperature_compensation
 parameters:
   readings_to_calibrate: stage import_readings

stage plot_normal_bias_offset:
 function: plot_readings
 parameters:
   readings_to_plot: stage apply_temp_compensation
   IP_export_folder: ./readings/fullsphere/plots/
   IP_plot_headline_prefix:  Sample N45 12x12x12 magnets calibrated

stage export_readings:
 function: export_readings
 parameters:
   readings_to_plot: stage apply_temp_compensation
   IP_export_folder: ./readings/fullsphere/plots/
\end{lstlisting}

\hypertarget{package-distribution}{%
\section{Package distribution}\label{package-distribution}}

\begin{figure}
\centering
\includegraphics{./generated_images/border_MagneticReadoutProcessing_library_hosted_on_PyPi.png}
\caption{MagneticReadoutProcessing library hosted on PyPi
\label{MagneticReadoutProcessing_library_hosted_on_PyPi.png}}
\end{figure}

One important point that improves usability for users is the simple
installation of the library. As it was created in the Python programming
language, there are several public package directories where users can
provide their software modules. Here,
\passthrough{\lstinline!PyPi!}\cite{PyPI}\ref{MagneticReadoutProcessing_library_hosted_on_PyPi.png}\cite{MagneticReadoutProcessingPyPI}
is the most commonly used package directory and offers direct support
for the package installation programm \gls{pip}.

In doing so, \gls{pip} not only manages possible package dependencies,
but also manages the installation of different versions of a package. In
addition, the version compatibility is also checked during the
installation of a new package, which can be resolved manually by the
user in the event of conflicts.

\begin{lstlisting}[language=bash]
  # https://pypi.org/project/MagneticReadoutProcessing/
  # install the latest version
  $ pip3 install MagneticReadoutProcessing
  # install the specific version 1.4.0
  $ pip3 install MagneticReadoutProcessing==1.4.0
\end{lstlisting}

To make the library compatible with the package directory, Python
provides separate installation routines that build a package in an
isolated environment and then provide an installation
\passthrough{\lstinline!wheel!} archive. This can then be uploaded to
the package directory.

Since the library requires additional dependencies
(e.g.~\passthrough{\lstinline!numpy!},
\passthrough{\lstinline!matplotlib!}), which cannot be assumed to be
already installed on the target system, these must be installed prior to
the actual installation. These can be specified in the library
installation configuration \passthrough{\lstinline!setup.py!} for this
purpose.

\begin{lstlisting}[language=Python]
  # $ cat ./setup.py

  # dynamic requirement loading using 'requirements.txt'
  req_path = 'requirements.txt'
  with pathlib.Path(req_path).open() as requirements_txt:
      install_requires = [str(requirement) for requirement in pkg_resources.parse_requirements(requirements_txt)]

  setup(name='MagneticReadoutProcessing',
        version='1.4.3',
        url='https://github.com/LFB-MRI/MagnetCharacterization/',
        packages= ['MRP', 'MRPcli', 'MRPudpp', 'MRPproxy'],
        install_requires=install_requires,
        include_package_data=True,
        package_data={"": ["**/*.mag.json", "**/*.yaml", "**/*.html", "**/*.js", "**/*.css", "**/*.md", "**/*.json", "**/*.ts", "**/*.xml"]},
        entry_points={
            'console_scripts': [
              'MRPCli = MRPcli.cli:run',
              'MRPUdpp = MRPudpp.uddp:run',
              'MRPproxy = MRPproxy.mrpproxy:run'
            ]
        }
      )
\end{lstlisting}

To make the \gls{cli} scripts written in Python easier for the user to
execute without having to use the \passthrough{\lstinline!python3!}
prefix. This has been configured in the installation configuration using
the \passthrough{\lstinline!entry\_points!} option, and the following
commands are available to the user:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!MRPcli --help!} instead of
  \passthrough{\lstinline!python3 cli.py --help!}
\item
  \passthrough{\lstinline!MRPudpp --help!} instead of
  \passthrough{\lstinline!python3 udpp.py --help!}
\item
  \passthrough{\lstinline!MRPproxy --help!} instead of
  \passthrough{\lstinline!python3 proxy.py --help!}
\end{itemize}

In addition, these commands are available globally in the system without
the terminal shell being located in the library folder.

\hypertarget{documentation}{%
\subsection{Documentation}\label{documentation}}

\begin{figure}
\centering
\includegraphics{./generated_images/border_MagneticReadoutProcessing_documentation_hosted_on_ReadTheDocs.png}
\caption{MagneticReadoutProcessing documentation hosted on ReadTheDocs
\label{MagneticReadoutProcessing_documentation_hosted_on_ReadTheDocs.png}}
\end{figure}

In order to provide comprehensive documentation for the user, the source
code was documented using
Python-\passthrough{\lstinline!docstrings!}\cite{PythonDocstringReference}.
This includes, among other things:

\begin{itemize}
\tightlist
\item
  Function description
\item
  Input parameters - \passthrough{\lstinline!param!} and
  \passthrough{\lstinline!type!}
\item
  Return value - \passthrough{\lstinline!returns!},
  \passthrough{\lstinline!rtype!}
\end{itemize}

\begin{lstlisting}[language=Python]
    # MRPDataVisualisation.py - example docstring
    def plot_temperature(_readings: [MRPReading.MRPReading], _title: str = '', _filename: str = None, _unit: str = "degree C") -> str:
        """
        Plots a temperature plot of the reading data as bar-graph figure

        :param _readings: readings to plot
        :type _readings: list(MRPReading.MRPReading)

        :param _title: Title text of the figure, embedded into the head
        :type _title: str

        :param _filename: export graphic to an given absolute filepath with .png
        :type _filename: str

        :returns: returns the filepath of the generated .png image file
        :rtype: str
        """

        if _readings is None or len(_readings) <= 0:
            raise MRPDataVisualizationException("no readings in _reading given")
        num_readings = len(_readings)
        # ...
\end{lstlisting}

Since `docstrings' only document the source code, but do not provide
simple how-to-use instructions, the documentation framework
\passthrough{\lstinline!Sphinx!}\cite{SphinxDocumentation} was used
for this purpose. This framework makes it possible to generate
\gls{html} or \gls{pdf} documentation from various source code
documentation formats, such as the used
\passthrough{\lstinline!docstrings!}. These are converted into a
Markdown format in an intermediate step and this also allows to add
further user documentation such as examples or installation
instructions.

In order to make the documentation created by
\passthrough{\lstinline!Sphinx!} accessible to the user, there are, as
with the package management by \passthrough{\lstinline!PyPi!} services,
which provide Python library documentation online.

\cite{ReadTheDocs}

\cite{MagneticReadoutProcessingReadTheDocs}

\ref{MagneticReadoutProcessing_documentation_hosted_on_ReadTheDocs.png}

\hypertarget{tests}{%
\subsection{Tests}\label{tests}}

\hypertarget{evaluation}{%
\chapter{Evaluation}\label{evaluation}}

\hypertarget{prequesites-for-evaluation}{%
\section{Prequesites for evaluation}\label{prequesites-for-evaluation}}

\begin{figure}
\centering
\includegraphics{./generated_images/border_testmagnets_in_holder.png}
\caption{testmagnets in holder \label{testmagnets_in_holder.png}}
\end{figure}

\hypertarget{evaluation-confiugration}{%
\section{Evaluation confiugration}\label{evaluation-confiugration}}

\hypertarget{sensor-readout}{%
\subsection{Sensor readout}\label{sensor-readout}}

\hypertarget{processing-pipeline}{%
\subsection{Processing pipeline}\label{processing-pipeline}}

\hypertarget{test-scenarios}{%
\section{Test scenarios}\label{test-scenarios}}

\hypertarget{results}{%
\section{Results}\label{results}}

\hypertarget{conclusion-and-dicussion}{%
\chapter{Conclusion and dicussion}\label{conclusion-and-dicussion}}

\hypertarget{conclusion}{%
\section{Conclusion}\label{conclusion}}

\hypertarget{problems}{%
\section{Problems}\label{problems}}

\hypertarget{outlook}{%
\section{Outlook}\label{outlook}}

\begin{itemize}
\tightlist
\item
  magfield camera
\end{itemize}

